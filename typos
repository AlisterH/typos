#!/usr/bin/perl -w
# Copyright (C) 2005-2007 Francois Gouget
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
use strict;
use FileHandle;
use File::Basename;
use Cwd;

my $name0=$0;
$name0 =~ s%^.*/%%;


my $RE_BUNCH=30;

my $verbose;
sub verbose(@)
{
    return print STDERR @_ if ($verbose);
}

my $debug;
sub debug(@)
{
    return print STDERR @_ if ($debug);
}

sub err(@)
{
    print STDERR "$name0:error: ";
    print @_;
}

sub warning(@)
{
    print STDERR "$name0:warning: ";
    print @_;
}


#####
#
# Building file scanners
#
#####

sub scan_check($$$$$$)
{
    my ($allsets, $category, $filename, $lineno, $line, $regexps)=@_;
    my $current=$allsets->{current};
    my $ignore_re=$current->{_ignore_re};

    foreach my $item (@$regexps)
    {
        my $regexp=sprintf($current->{"${category}_format"}, $item);
        next if ($line !~ /$regexp/);
        next if (defined $ignore_re and $line =~ /$ignore_re/);
        if ($current->{"by-error"})
        {
            my $group=$current->{$category}->{$item};
            push @{$allsets->{errors}->{$group}}, "$filename:$lineno: $line";
        }
        else
        {
            print "$filename:$lineno: $line";
            return 1;
        }
    }
    return 0;
}

sub scan_check_extra($$$$$$)
{
    my ($allsets, $category, $filename, $lineno, $line, $regexps)=@_;
    my $current=$allsets->{current};
    my $ignore_re=$current->{_ignore_re};

    foreach my $item (@$regexps)
    {
        my $regexp=sprintf($current->{"${category}_format"}, $item);
        my $match;
        if ($line =~ /(?:\b|[0-9_])(?:$regexp)(?:\b|[0-9_])/)
        {
            $match=1;
        }
        elsif ($line =~ /[a-z](?:$regexp)(?:\b|[0-9_])\b/)
        {
            my $matched=$&;
            $match=1 if ($matched =~ /^[a-z][A-Z][a-z]*$/);
        }
        elsif ($line =~ /[a-z](?:$regexp)[A-Z]/)
        {
            my $matched=$&;
            $match=1 if ($matched =~ /^[a-z][A-Z][a-z]*[A-Z]$/);
        }
        elsif ($line =~ /(?:\b|[0-9_])(?:$regexp)[A-Z]/)
        {
            my $matched=$&;
            $match=1 if ($matched =~ /^[A-Z][a-z]*[A-Z]$/);
        }
        next if (!$match);
        next if (defined $ignore_re and $line =~ /$ignore_re/);
        if ($current->{"by-error"})
        {
            my $group=$current->{$category}->{$item};
            push @{$allsets->{errors}->{$group}}, "$filename:$lineno: $line";
        }
        else
        {
            print "$filename:$lineno: $line";
            return 1;
        }
    }
    return 0;
}

sub build_scan_check($$$)
{
    my ($allsets, $current, $category)=@_;

    my @code;
    my @list=sort keys %{$current->{$category}};
    my $checker;
    if ($category eq "_bad-word" and $current->{extra})
    {
        $checker="scan_check_extra";
    }
    else
    {
        $checker="scan_check";
    }
    my $i=0;
    while ($i < @list)
    {
        my @buf;
        for (my $j=$i; $j < $i+$RE_BUNCH and $j < @list; $j++)
        {
            push @buf, $list[$j];
        }
        $i+=$RE_BUNCH;
        my $regexp="(?:" . join("|", @buf) . ")";
        $regexp=sprintf($current->{"${category}_format"}, $regexp);
        push @code, ("if (\$line =~ /$regexp/)",
                     "{",
                     "    my \$regexps=[",
                     (map { "        " . quote_string($_) . "," } @buf),
                     "    ];",
                     "    if ($checker(\$allsets, " . quote_string($category) . ", \$filename, \$lineno, \$line, \$regexps))",
                     "    {",
                     "        next;",
                     "    }",
                     "}");
    }
    return @code;
}

sub build_scanner($$)
{
    my ($allsets, $current)=@_;

    $current->{"_bad-word_format"}=$current->{extra} ? "(?i)\%s" : "(?i)(?:\\b|[0-9_])\%s(?:\\b|[0-9_])";
    $current->{"_bad-expression_format"}="(?i)\%s";
    $current->{"_bad-case_format"}="\\b\%s\\b";
    my @code=("sub ",
              "{",
              "    my (\$fh, \$filename)=\@_;",
              "",
              "    my \$lineno=0;",
              "    while (my \$line=<\$fh>)",
              "    {",
              "        \$lineno++;",
              build_scan_check($allsets, $current, "_bad-word"),
              build_scan_check($allsets, $current, "_bad-expression"),
              build_scan_check($allsets, $current, "_bad-case"),
              "    }",
              "}",
              "");
    if ($debug)
    {
        my $fh=FileHandle->new(">#code.txt#");
        if ($fh)
        {
            print $fh join("\n", @code);
            close ($fh);
        }
    }
    $current->{scanner}=eval join("\n", @code);
    if ($@)
    {
        err("scanner compilation error: $@\n");
        exit 1;
    }
}


#####
#
# Command-line and rc file processing
#
#####

sub get_true_by_default($)
{
    my ($value)=@_;
    return (defined $value ? $value : 1);
}

sub rchandle2argv($$)
{
    my ($fh, $filename)=@_;
    verbose("reading '$filename'\n");

    my $argv=[];
    my $lines=[];
    my $repeat;
    my $lineno=0;
    while (my $line=<$fh>)
    {
        $lineno++;
        next if ($line =~ /^\s*#/);
        chomp $line;
        if (defined $repeat)
        {
            if ($line =~ s/^\s+// and $line ne "")
            {
                push @$argv, $repeat, $line;
                push @$lines, $lineno, $lineno;
                next;
            }
            $repeat=undef;
        }
        if ($line =~ s/^([-a-z0-9_]+)\s*=\s*//)
        {
            if ($line eq "")
            {
                $repeat="--$1";
            }
            else
            {
                push @$argv, "--$1", $line;
                push @$lines, $lineno, $lineno;
            }
        }
        elsif ($line =~ /^[a-z0-9_]+$/)
        {
            push @$argv, "--$line";
            push @$lines, $lineno;
        }
        elsif ($line !~ /^\s*$/)
        {
            err("$filename:$lineno: invalid line format: $line\n");
            return undef;
        }
    }
    close($fh);
    debug("  -> @$argv\n");
    return ($argv, $lines);
}

sub cvsignore2argv($$)
{
    my ($allsets, $filename)=@_;

    my $fh=FileHandle->new($filename);
    if (!$fh)
    {
        err("unable to open '$filename' for reading: $!\n");
        exit 1;
    }
    verbose("reading '$filename'\n");

    my $argv=[];
    my $lines=[];
    my $lineno=0;
    while (my $line=<$fh>)
    {
        $lineno++;
        chomp $line;
        foreach my $glob (split / +/, $line)
        {
            $glob =~ s!([{}().+^|\$])!\\$1!g;
            if ($glob !~ s!\*$!!)
            {
                # Globs must implicitly match up to the end of the string
                $glob .= "\$";
            }
            $glob =~ s!\?!.!g;
            $glob =~ s!\*![^/]*!g;
            # The CVS globs only match files in the current directory
            push @$argv, "--exclude", "^./$glob";
            push @$lines, $lineno, $lineno;
        }
    }
    close($fh);
    debug("  -> @$argv\n");
    return ($argv, $lines);
}

sub gitignore2argv($$)
{
    my ($allsets, $filename)=@_;

    my $fh=FileHandle->new($filename);
    if (!$fh)
    {
        err("unable to open '$filename' for reading: $!\n");
        exit 1;
    }
    verbose("reading '$filename'\n");

    my $argv=[];
    my $lines=[];
    my $lineno=0;
    while (my $glob=<$fh>)
    {
        $lineno++;
        chomp $glob;
        $glob =~ s/^\s*//;
        $glob =~ s/\s*$//;
        next if ($glob eq "" or $glob =~ /^#/);

        my $option=($glob =~ s/^!\s*// ? "--include" : "--exclude");
        $glob =~ s!([{}().+^|\$])!\\$1!g;
        if ($glob =~ s!^\*!!)
        {
            # No need for the '*' prefix with regular expressions
            ;
        }
        elsif ($glob =~ s!^/!^./!)
        {
            # This only matches files in the current directory
            # We will replace the '^./' prefix with the absolute path
            # a bit later
            ;
        }
        else
        {
            # Globs must implicitly match from the start of the string,
            # in this case from the start of the basename
            $glob = "/$glob";
        }
        if ($glob !~ s!\*$!!)
        {
            # Globs must implicitly match up to the end of the string
            $glob .= "\$";
        }
        $glob =~ s!\?!.!g;
        $glob =~ s!\*![^/]*!g;
        push @$argv, $option, $glob;
        push @$lines, $lineno, $lineno;
    }
    close($fh);
    debug("  -> @$argv\n");
    return ($argv, $lines);
}

sub get_options_set($$$;$)
{
    my ($argv, $lines, $filename, $extra_options)=@_;
    @ARGV=@$argv if (defined $argv);

    use Getopt::Long;
    Getopt::Long::Configure("pass_through");
    my ($opt_set, @extra);
    if ($extra_options)
    {
        $opt_set=$extra_options;
        @extra=keys %$extra_options;
    }
    else
    {
        $opt_set={};
        @extra=();
    }
    GetOptions($opt_set, @extra,
               "builtin!",
               "rc!",
               "cvsignore!",
               "gitignore!",

               "extra!",
               "bad-word=s@",
               "bad-expression=s@",
               "bad-case=s@",
               "ignore=s@",
               "by-error!",

               "get-wikipedia",
               "wikipedia",
               "wiki-file=s",

               "all!",
               "include=s@",
               "exclude=s@");
    if (@ARGV)
    {
        my $i=0;
        foreach my $item (@ARGV)
        {
            if (defined $argv)
            {
                while ($item ne $argv->[$i])
                {
                    $i++;
                }
                err("$filename:$lines->[$i]: unknown option '$item'\n");
            }
            else
            {
                err("unknown option '$item'\n");
            }
        }
        return undef;
    }

    $opt_set->{builtin}=1 if (!defined $opt_set->{builtin});
    $opt_set->{rc}=1 if (!defined $opt_set->{rc});
    $opt_set->{_filename}=$filename;

    # Convert the paths relative to this directory
    my $cur_dir=($filename =~ m!/! ? dirname($filename) : cwd());
    $cur_dir =~ s!([{}()?.*+^|\$])!\\$1!g;
    foreach my $key ("include", "exclude")
    {
        if (defined $opt_set->{$key})
        {
            map { s!^\^\./!^$cur_dir/! } @{$opt_set->{$key}};
        }
    }
    # FIXME: Check each regular expression and try to match them to line numbers if they don't compile

    return $opt_set;
}

sub read_rc_files($$)
{
    my ($allsets, $dir)=@_;
    my $opt_set;

    my $filename="$dir/.typosrc";
    if (-f $filename)
    {
        my $fh=FileHandle->new($filename);
        if (!$fh)
        {
            err("unable to open '$filename' for reading: $!\n");
            exit 1;
        }
        my ($argv, $lines)=rchandle2argv($fh, $filename);
        close($fh);
        $opt_set=get_options_set($argv, $lines, $filename);
        push @{$allsets->{rcstack}}, $opt_set;
    }

    # FIXME: Also take into account $CVSROOT/CVSROOT/cvsignore?
    # FIXME: Also take into account $HOME/.cvsignore
    # FIXME: Also take into account $CVSIGNORE
    $filename="$dir/.cvsignore";
    if (get_true_by_default($allsets->{cmdline}->{cvsignore}) and
        get_true_by_default($opt_set->{cvsignore}) and
        -f $filename)
    {
        my ($argv, $lines)=cvsignore2argv($opt_set, $filename);
        push @{$allsets->{rcstack}}, get_options_set($argv, $lines, $filename);
    }

    $filename="$dir/.gitignore";
    if (get_true_by_default($allsets->{cmdline}->{gitignore}) and
        get_true_by_default($opt_set->{gitignore}) and
        -f $filename)
    {
        my ($argv, $lines)=gitignore2argv($opt_set, $filename);
        push @{$allsets->{rcstack}}, get_options_set($argv, $lines, $filename);
    }
}

sub merge_regexp_list($$$)
{
    my ($hashed, $key, $list)=@_;

    foreach my $item (@$list)
    {
        # Copy $item to avoid the in-place modification of $list
        my $regexp=$item;
        my $group=($regexp =~ s/\s+->\s+(.*)$// ? $1 : $regexp);
        $regexp =~ s/\((?!\?)/(?:/g;
        next if ($regexp eq "");
        if (!exists $hashed->{$key}->{$regexp})
        {
            $hashed->{$key}->{$regexp}=$group;
        }
        elsif ($hashed->{$key}->{$regexp} eq $group)
        {
            verbose("duplicate regular expression '$regexp': '$hashed->{$key}->{$regexp}' and '$group'\n");
        }
        else
        {
            verbose("different groups found for regular expression '$regexp': '$hashed->{$key}->{$regexp}' and '$group'\n");
        }
    }
}

sub merge_option_set($$$)
{
    # FIXME: Do we need $allsets here???
    my ($allsets, $merged, $opt_set)=@_;
    verbose("merging '$opt_set->{_filename}'\n"); # FIXME: debug

    foreach my $key (keys %{$opt_set})
    {
        if (!ref $opt_set->{$key})
        {
            if (!exists $merged->{$key})
            {
                $merged->{$key}=$opt_set->{$key};
            }
            elsif ($key !~ /^(_|rc$|builtin$)/)
            {
                verbose("found duplicate '$key' option in '$opt_set->{_filename}'\n");
            }
        }
        elsif ($key =~ /^(bad-word|bad-expression|bad-case|ignore|include|exclude)$/)
        {
            merge_regexp_list($merged, "_$key", $opt_set->{$key});
        }
    }
}

sub get_current_options($$)
{
    my ($allsets, $dir)=@_;
    my $new;

    if ($allsets->{cmdline}->{rc})
    {
        read_rc_files($allsets, $dir);
    }
    else
    {
        $new=$allsets->{merged_stack}->[-1];
    }
    if (!$new)
    {
        $new={};
        # Merge all the option sets into one
        merge_option_set($allsets, $new, $allsets->{cmdline});
        $new->{rcdepth}=(defined $allsets->{rcstack} ? @{$allsets->{rcstack}} : 0);
        if ($allsets->{cmdline}->{rc} and defined $allsets->{rcstack})
        {
            my $i=$new->{rcdepth};
            while ($i > 0)
            {
                $i--;
                merge_option_set($allsets, $new, $allsets->{rcstack}->[$i]);
                debug("new_exclude=[",join(" | ",keys %{$new->{_exclude}}), "]\n");
                last if (!$new->{rc});
            }
        }
        if ($new->{builtin})
        {
            merge_option_set($allsets, $new, $allsets->{builtin});
        }
        if ($new->{all})
        {
            delete $new->{_include};
        }
        else
        {
            $new->{_include_re}=list_to_regexp($new->{_include});
        }
        $new->{_exclude_re}=list_to_regexp($new->{_exclude});
        $new->{_ignore_re}=list_to_regexp($new->{_ignore});
        # FIXME: Try not to rebuild the scanner if not strictly necessary
        build_scanner($allsets, $new);
    }
    push @{$allsets->{merged_stack}}, $new;
    $allsets->{current}=$new;
    return $new;
}

sub pop_current_options($)
{
    my ($allsets)=@_;

    pop @{$allsets->{merged_stack}};
    $allsets->{current}=$allsets->{merged_stack}->[-1];
    if ($allsets->{rcstack})
    {
        my $rcdepth=$allsets->{current} ? $allsets->{current}->{rcdepth} : 0;
        splice @{$allsets->{rcstack}}, $rcdepth;
    }
}


#####
#
# Read the bad words
#
#####

sub split_spec_line($)
{
    my ($spec)=@_;
    return ($1, $2) if ($spec =~ /^(.*)\s*-(?:>|&gt;)\s*(.*)$/);
    return ($spec);
}

sub list_to_regexp($)
{
    my ($list)=@_;
    return undef if (!defined $list or !%$list);
    return "(?:" . join("|", keys %$list) . ")";
}

sub quote_string($)
{
    my ($str)=@_;
    $str =~ s!\\!\\\\!g;
    $str =~ s!([\"\$\@\%])!\\$1!g;
    return "\"$str\"";
}

sub scan_file($$$)
{
    my ($allsets, $current, $filename)=@_;

    my $fh=FileHandle->new("$allsets->{rootdir}/$filename");
    if (!$fh)
    {
        err("unable to open '$filename' for reading: $!\n");
        return 0;
    }
    verbose("scanning '$filename'\n");
    $current->{scanner}($fh, $filename);
    close($fh);
}

sub scan_directory($$);
sub scan_directory($$)
{
    my ($allsets, $dir)=@_;
    verbose("Entering the ", ($dir ? "'$dir'" : "root"), " directory\n");

    my $current=get_current_options($allsets, "$allsets->{rootdir}/$dir");
    debug("current options=[",join(" ", keys %$current),"]\n");
    my $include_re=$current->{_include_re};
    my $exclude_re=$current->{_exclude_re};
    debug("exclude_re=[$exclude_re]\n");

    my @subdirs;
    local *DIR;
    if (!opendir DIR, "$allsets->{rootdir}/$dir")
    {
        err("unable to open the '$allsets->{rootdir}/$dir' directory\n");
        pop_current_options($allsets);
        debug("Exiting the ", ($dir ? "'$dir'" : "root"), " directory\n");
        return;
    }
    foreach my $dentry (readdir(DIR))
    {
        next if ($dentry eq "." or $dentry eq "..");
        $dentry="$dir$dentry";
        my $fullpath="$allsets->{rootdir}/$dentry";
        if (-d $fullpath)
        {
            if (-l $fullpath)
            {
                debug("$dentry/: skipping directory symbolic link\n");
                next;
            }
            $fullpath.="/";
            if ($exclude_re and $fullpath =~ /$exclude_re/)
            {
                verbose("$dentry/: skipping blacklisted directory\n");
                next;
            }
            push @subdirs, $dentry;
            next;
        }
        if (defined $include_re and $fullpath !~ /$include_re/)
        {
            verbose("$dentry: not in whitelist, skipped\n");
            next;
        }
        if ($exclude_re and $fullpath =~ /$exclude_re/)
        {
            verbose("$dentry: skipping blacklisted file\n");
            next;
        }
        scan_file($allsets, $current, $dentry);
    }
    closedir(DIR);

    foreach my $subdir (@subdirs)
    {
        scan_directory($allsets, "$subdir/");
    }
    pop_current_options($allsets);
    debug("Exiting the ", ($dir ? "'$dir'" : "root"), " directory\n");
}

sub print_errors($)
{
    my ($allsets)=@_;
    foreach my $group (sort keys %{$allsets->{errors}})
    {
        print "\n$group:\n";
        print @{$allsets->{errors}->{$group}};
    }
}


#####
#
# Main
#
#####

my ($opt_help);
my $global_options={"debug"   => \$debug,
                    "verbose" => \$verbose,
                    "help"    => \$opt_help
                   };
my $allsets={ rootdir => cwd() };
$allsets->{cmdline}=get_options_set(undef, undef, "cmdline", $global_options);
if (!defined $allsets->{cmdline})
{
    err("try running $name0 --help\n");
    exit 2;
}
$verbose=1 if ($debug);
if ($opt_help)
{
    print "Usage: $name0 [--bad-word WORD] [--bad-expression EXPR] [--bad-case CASE]\n";
    print "             [--ignore IGNORE] [--extra] [--by-error]\n";
    print "             [--get-wikipedia] [--wikipedia] [--wiki-file FILE]\n";
    print "             [--include SCAN] [--exclude SKIP] [--all]\n";
    print "             [--no-builtin] [--no-rc] [--no-cvsignore] [--no-gitignore]\n";
    print "             [--debug] [--verbose] [--help]\n";

    print "\n";
    print "Scans files for common misspellings and case errors.\n";

    print "\n";
    print "Options:\n";
    print "  --bad-word WORD   A pattern identifying a common typo. This pattern is\n";
    print "                      applied in a case-insensitive way, and can only match\n";
    print "                      full words. It is specified in the following format:\n";
    print "                        PATTERN -> CORRECT\n";
    print "                      Where PATTERN is a Perl regular expression, And CORRECT\n";
    print "                      is the correct spelling of that word\n";
    print "  --bad-expression EXPR A pattern identifying a common typo. This pattern is\n";
    print "                        applied in a case-insensitive way but can span two or\n";
    print "                        more words. It is specified in the same format as the\n";
    print "                        --bad-word argument\n";
    print "  --bad-case CASE   A pattern identifying a common case typo. This pattern is\n";
    print "                        applied in a case-sensitive way, and can only match\n";
    print "                      full words. It is specified in the same format as the\n";
    print "                        --bad-word argument\n";
    print "  --ignore IGNORE   A pattern identifying typos to ignore. This is used to\n";
    print "                      ignore intentional misspellings, or to avoid false\n";
    print "                      positives. It is specified in the following format:\n";
    print "                        PATTERN\n";
    print "                      Where PATTERN is a Perl regular expression\n";
    print "  --extra           If set, then $name0 will consider 'FirstSecond' and\n";
    print "                      'first_second' to be made of two separate words that can\n";
    print "                      be matched by the --bad-word and --bad-case patterns\n";
    print "  --by-error        By default errors are reported in the order in which they\n";
    print "                      are found in the files. If this option is specified, all\n";
    print "                      errors of a given type are reported together after all\n";
    print "                      files have been scanned\n";
    print "  --get-wikipedia   Download Wikipedia's list of common misspelling's\n";
    print "                      FIXME: Not implemented yet\n";
    print "  --wikipedia       Use Wikipedia's list of common misspellings\n";
    print "                      FIXME: Not implemented yet\n";
    print "  --wiki-file FILE  Specifies an alternate file containing the Wikipedia common misspellings\n";
    print "                      FIXME: Not implemented yet\n";
    print "  --all             Scan all files not matched by an exclude file pattern\n";
    print "                      By default, only files matching an include file pattern\n";
    print "                      and not matching an exclude file pattern are scanned\n";
    print "  --include SCAN    A Perl regular expression identifying files to scan\n";
    print "  --exclude SKIP    A Perl regular expression identifying files not to scan,\n";
    print "                      typically because they are binary or duplicate files\n";
    print "  --no-builtin      Don't use the builtin list of typos and files scanning options\n";
    print "  --no-rc           Ignore the .typosrc configuration files\n";
    print "  --no-cvsignore    By default $name0 does not scan the files mentionned in the\n";
    print "                      CVS .cvsignore files\n";
    print "  --no-gitignore    By default $name0 does not scan the files mentionned in\n";
    print "                      Git's .gitignore files\n";
    print "  --debug           Prints debug traces\n";
    print "  --verbose         Be more verbose\n";
    print "  --help            Prints this usage message\n";

    print "\n";
    print "File patterns:\n";
    print "  Patterns starting with '^./' identify files relative to the corresponding\n";
    print "  .typosrc directory, or to the current directory for command line options.\n";
    print "   All other file patterns are matched against the file's full path name.\n";
    exit 0;
}

if ($allsets->{cmdline}->{rc})
{
    my $path=cwd();
    my @stack;
    while (1)
    {
        $path=dirname($path);
        last if (!-o $path or $path eq "/");
        unshift @stack, basename($path);
    }
    foreach my $dir (@stack)
    {
        $path="$path/$dir";
        read_rc_files($allsets, $path);
    }
}

if ($allsets->{cmdline}->{builtin})
{
    # Read builtin files
    my ($argv, $lines)=rchandle2argv(*DATA, "builtin");
    $allsets->{builtin}=get_options_set($argv, $lines, "builtin");
}

# FIXME: Wrong place for this, should be done somewhere in get_current_options()
#if ($opt_wikipedia)
#{
#    $opt_wiki_file=dirname($0) . ".wikipedia" if (!defined $opt_wiki_file);
#}

scan_directory($allsets, "");
print_errors($allsets);

exit 0;

__DATA__
# From the Top 100 misspelled English words.
# http://www.yourdictionary.com/library/misspelled.html
bad-word=
    ac(c?epti|ept[ai])ble -> acceptable
    ac(c?ident|idental?)ly -> accidentally
    ([iu]n)?ac(c?omo|omm?o)dat(e[ds]?|ing|ingly) -> accommodate
    ([iu]n)?ad?quir(e[ds]?|ing) -> acquire
    ad?quit(ed)? -> acquit
    alot -> a lot
    amat(er|u?re)s? -> amateur
#apparent
    arguement(e[ds]?|ing|s)? -> argument
    at(ei|hie)st -> atheist
    bele?ive -> believe
    bellw(he|ea)ther -> bellwether
    caland[ae]rs?|calenders? -> calendar
    cateogor(y|ies)|catigory -> category
    cemeta?ry|semet[ae]?ry -> cemetery
#   changable -> changeable   Also handled by the '...able' rule
#collectable and collectible are both valid
    col(lumn?|um) -> column
    com(mit|itt?)(al|e[de]|ers?|ing) -> committed
    con(ch?|s|t)ience -> conscience
    con(ch?|s|t)ien(t|sc|ch?)ious(ly)? -> conscientious
    con(sc?|ch?|t)ien(sc|ch?)ious(ly)? -> conscientious
    con(ch?|s|t)ious -> conscious
    concensus -> consensus
#daiquiri
    definit -> definite
    definate?ly|definitly -> definitely
    di[sc]ipline -> discipline
    drunkeness -> drunkenness
    dumb(be|el?)ls? -> dumbbell
    embar(ra|as?)s(ed|ing(ly)?|ments?)? -> embarrass
    equip[et]ments? -> equipment
    exilarat(e[ds]?|ing(ly)?|ion) -> exhilarate
    exced(e[ds]?|ing(ly)?) -> exceed
    existan(ce|t(ial(ism|ists?)?)?) -> existence
    experiance[ds]? -> experience
    firy -> fiery
    foriegn -> foreign
    guage -> gauge
    greatful -> grateful
    g(a|uar)r[ae]nt(ee?d?|ies|y)|guarr?[ae]nted? -> guarantee
    harrass -> harass
    heigh?ths? -> height
#   hierarchy -> see bad-expression
    humorus -> humorous
    ignoren(ce|t(ly)?) -> ignorance
    im(edi|med)ate?(ly)? -> immediate
    indep(enda|and[ea])n(ce|t(e?ly)?) -> independent
    indispensible -> indispensable
    innoculat(e[ds]?|ing|ion) -> inoculate
    intel(ig[ae]|lige?a)n(ce|t(e?ly|sia)?) -> intelligence
#its and it's only differ in their meaning
    jewelery -> jewelry or jewellery
#judgment and judgement are both valid
#kernel
    liesur(e|ly) -> leisure
    lia(s|i?z)ons? -> liaison
    libar(ies|y) -> library
    lisen[cs](e[ds]?|ing) -> license
#lightening and lightning only differ in their meaning
    maintainance -> maintenance
#maneuver
    midieval -> medieval
    momento -> memento
    mil(en?|le)ni(a|um) -> millennium
    min[ai]tures? -> miniature
#minuscule and miniscule are both valid
    mi(chi?evi?|schev|schi?evi)ous -> mischievous
    mispell(e[ds]?|ings?|s)? -> misspell
    n(ei|ie(gh)?)bou?r(hood)?s? -> neighbor
    (un)?noticabl[ey] -> noticeable
    oc(cas|as?)sion(n?ally|s)? -> occasionally
    oc(urr|cur)(e[ds]?|ences?|ing)|occ?urr?ances? -> occurrence
    pas[st]times? -> pastime
    perseveren(ce|t) -> perseverance
    personel -> personnel
    playrights? -> playwright
    pos(e|es|se)s(e[ds]?|ing|ions?) -> possession
    preceed(e[ds]?|ing(ly|s)?|s)? -> precede
#principal and principle only differ in their meaning
    privi?l(a|ed)ge[ds]? -> privilege
    pronounciations? -> pronunciation
    publicall?y -> publicly
    question(aire?|nair)s? -> questionnaire
    rebel(ed|ing) -> rebelled
#   receive -> see bad-expression
    reciepts? -> receipt
    recom(e|m?a)nd(ab(ility|le)|ed|ing|s) -> recommend
    refer(re|a)nc(e[ds]?|ing) -> reference
    refer(ed|ing) -> referred
    relevent|revel[ae]nt -> relevant
#restaurant
    remit(ed|ing) -> remitted
    rythms? -> rhythm
    shedul(e[ds]?|ers?|ing) -> schedule
    sep(era|are)t(e[ds]?|e?ly|ing|ions?|ors?) -> separate
    sargeants?|sergents? -> sergeant
    supercee?d(e[ds]?|ing|s)?|superseed(e[ds]?|ing|s)?|superseds -> supersede
#their, they're and there only differ in their meaning
    threshholds? -> threshold
    twelth -> twelfth
    tiran?n(ts?|y)|tyrany -> tyranny
    untill -> until
    vacc?u(me?|ume) -> vacuum
    wether -> whether or weather
    wierd(er|est|e?ly)? -> weird
bad-expression=
    \bheirar?ch|\bhierach -> hierarchy
    reciev -> receive

# From the Top 101-250 misspelled English words.
# http://www.yourdictionary.com/library/150more.html
bad-word=
    abscen(ces?|t(e?ly|ee(ism)?)?) -> absence
    acc?ellerat(e[ds]?|ing|or) -> accelerate
    acomplish(ed|ing)? -> accomplish
#accordion
    acumulat(e[ds]?|ing|or) -> accumulate
    aquaintance -> acquaintance
    ac(cros?|c?ro)s -> across
    afficionn?ados?|aficionnados? -> aficionado
#anoint
#apology
#a while: 'awhile' is a valid word too
#barbecue
    begining -> beginning
    broc(col|ol?)li -> broccoli
    bu(is[iy]|sy)ness(es|like|(wo)?m[ae]n) -> business
#camouflage
#candidate
#cantaloupe
    carburatt?or -> carburetor or carburettor
#Caribbean
#cartilage
#chauvinism
#chocolaty
#coliseum
#colonel
    comemorate -> commemorate
#congratulations
    cooly -> coolly
    critisiz(e[ds]?|ing) -> criticize
#Dalmatian
    deciev(e[ds]?|ing) -> deceive
    defendents? -> defendant
#defiant
    des(sic?|s?i)ca(nts?|te[sd]?|ting|tion) -> desiccate
#desperate
    deterrance -> deterrence
    developpe(d|ing|rs?) -> developer
    developements? -> development
    differances? -> difference
#diorama
    dis(sap?|s?a)pear(ances?|e[ds]?|ing|s)? -> disappear
    dis(sap?|s?a)point(e[ds]?|ing|ments?|s) -> disappoint
    dis(ip?|s?ip)pat(e[ds]?|ion) -> dissipate
    e(cs|x)tacy|exta[cs]y -> ecstasy
    e?specialy -> especially
    excel(e|l?a)n(ce|t(ly)?) -> excellent
#exercise
    explaination -> explanation
#Fahrenheit
#flabbergast
    flottation -> flotation
# fulfill is the US spelling of fulfil
#genius
    governement(al) -> government
    grammer -> grammar
#gross
    gut(tur|ur?)ral -> guttural
#handkerchief
    horific -> horrific
    hypocr(a[cs]|ic)y -> hypocrisy
    immitat(e[ds]?|ing|ion) -> imitate
    inadvertant -> inadvertent
    incredabl[ey] -> incredible
#ingenious
#irascible
    irresistable -> irresistible
    knowlege|kowled?ge -> knowledge
#lieutenant
#liquefy
#marshmallow
#mischief
#misogyny
#missile
#nauseous
    noone -> no one
#octopus
    (un)?offical(ly|s)? -> official
#onomatopoeia
    par(r?a|ral?)lel(epiped|ism|ogram)? -> parallel
#parliament
#particular
#peninsula
#pharaoh
#physical
#pigeon
#pistachio
#pleasant
#plenitude
    preferible -> preferable
    presomptuous -> presumptuous
    proced(e?s|ing)? -> proceed
    propogat(e[ds]?|ing|ion) -> propagate
#puerile
#pursue
#putrefy
#raspberry
#refrigerator
#religious
    remembrence -> remembrance
#renowned
#ridiculous
#sacrilegious
#salary
#sandal
    sandw(hit?|it)ch -> sandwich
#savvy
#scissors
    siezed? -> seize
    sensabl[ey] -> sensible
#septuagenarian
    sherifs? -> sheriff
#shish kebab
    seige -> siege
    simmilar(ity|ly)? -> similar
    simmile -> simile
    subpoenna -> subpoena
    suc(ce|es?)s(ful(l|ly|y)?|ion|ive(ly)?|ors?)? -> success
    succ?ess?fuly -> successfully
#tableau
    tar(r?i|rif?)fs? -> tariff
    tom(mor?|m?o)row -> tomorrow
#tongue
    tradgedy -> tragedy
    truely -> truly
#ukulele
    useage -> usage
#vicious
#village
    with[eo]ld -> withhold
bad-expression=
    necces|necesar|\b(un)?nesses|nessary\b -> necessary

# Other common errors
bad-word=
    ([iu]n)?ac(c?e|es?)s(es|[ai]b(le|ility)|ing|ors?) -> accessibility
    ([iu]n)?acc?ess?ab(le|ility) -> accessibility
    ([iu]n)?ache?iv(able|e[ds]?|ers?|ing) -> achieve
    ac(c?o|om?)modat(es?|ing|ions?) -> accommodate
    acknowlege?ment -> acknowledge?ment
    addres(ed|es|ing)?|adress?(ed|es|ing)? -> address
    allowes -> allows
    allready -> already
    allways -> always
    all?way -> always
    altrought? -> although
    amout(ed|ing|s)? -> amount
    anali[sz]e[sd]? -> analyzed
    appartments? -> apartment
    arithmatic -> arithmetic
    (un)?asign(e[ds]|ing|e?ments?|s)? -> assign
    (un)?asum(e[ds]|ing|s)? -> assume
    aswell -> as well
    att?achements? -> attachment
    atleast -> at least
    automaticly -> automatically
    awfull -> awful
    bec(a|uau?)se -> because
    beeing? -> being
    boundr(y|ies) -> boundary
    (re)?caclulat(e[drs]?|ing(ly)?|ors?) -> calculate
    (re)?calcualt(e[drs]?|ing(ly)?|ors?) -> calculate
    cannt -> cannot
    ([iu]n)?capatib(le|iliti?es|ility) -> capable
    careful[ly] -> carefully
    catched -> caught
    childs -> children
    choosen -> chosen
    codeweaver -> CodeWeavers
    comands? -> command
    (be|in|up)?comming -> coming
    compar(as|[ai]si)ons? -> comparison
    ([iu]n)?compatab(le|ility|ilities) -> compatibility
    completly -> completely
    ([iu]n)?consistan(ci?es|cy|t|tly) -> consistency
    (dis)?contigous(ly)?|(dis)?continous(ly)? -> continuously
    contr(y|ies) -> country
    convertions? -> conversion
    (in)?cor(ect?|rec)ly -> correct
    corr?espondance -> correspondence
    coudn?t?|couln?t? -> could
    crosover -> CrossOver
    ([iu]n)?debug(able|e[drs]|ing) -> debugging
    (de|in)cres(e[ds]?|ing(ly)?) -> decrease
    defintions? -> definition
    (in)?dep[ea]nd[ea]nd -> dependent
    (in)?dep(enda|and[ea])nc(e|y|ies) -> dependence
    derivat(e[ds]?|ing) -> derive
    (in)?diferen(ces?|cing|t) -> different
    dissabl(e[ds]?|ing) -> disable
    dito -> ditto
    dynamicly -> dynamically
    easly -> easily
    editt(ed|ing|or) -> editing
    effecien(c[ey]|t(e?ly)?) -> efficience
    eigther -> either
    endianess? -> endianness
    enought -> enough
    eventhought? -> even though
    enviro(ne)?ments? -> environment
    excecut(able|e[ds]?|ing|ions?) -> execute
    ([iu]n?)e(xe|z)p(e|c|ec)t?(ed(ly)?|ing|(at)?ions?|s)? -> expect
    exlud(e[ds]?|ing) -> exclude
    (ex|im)plic(itely|te?ly|t) -> explicitly
    extentions? -> extension
    ([iu]n)?feasab(le|ility) -> feasible
    feild?(ed|ing|s)?|faild -> failed
    (un)?fomat(ed|ing|s)? -> format
    (un)?fortunatly -> fortunately
    funtion(ality|ally|e[ds]?|ing|s)? -> functionning
    garantee(d|s)? -> guarantee
    (un)?handel(e[ds]?|s|ing)? -> handle
    happends? -> happens
    (un)?helpfull -> helpful
    hexidecimal -> hexadecimal
    higly -> highly
    homogenous(ly)? -> homogeneous
    imutable -> immutable
    (ex|im)p(licite|icite?) -> implicit
    (un)?imp?l(ema?n|i?men?|eme?na)t(ations?|ed|ers?|ing|s)? -> implement
    (un)?iml(em[ae]?n|i?me?n|eme?na)t(ations?|ed|ers?|ing|s)? -> implement
    incase -> in case
    incure[ds]? -> incur
    identife[drs]? -> identifier
    inorder -> in order
    (dis)?informations -> information
    (un)?in(i?t[ai]|tia?)l(i[sz](ation|ators?|e[ds]?|ers?|ing)|s)? -> initial
    (un)?initiali[sz]aion -> initialization
    (un)?instal(able|ation|ed|ers?|ing|e?s)? -> installable
    (un)?intergrat(e[ds]?|ing|ion|or) -> integrated
    inte(f|r?fer)ac(e[ds]?|ing) -> interface
    interfers -> interferes
    (un?)interprett(ed|ers?|ing|ations?) -> interpreted
    (un)?int(er|re)st(e[ds]?|ing|s)? -> interest
    invokat(e[ds]?|ing|ion) -> invocation
    (ir)?revelant -> relevant
    (i?un)?kown -> known
    lenght(en|s)? ->length
    langages? -> language
    mesag(e[ds]?|ing) -> message
    minum(a|al(s|l?y)?|um) -> minimum
    ommit(e[ds]?|ing|ted|s)? -> omit
    oportunit(y|ies) -> opportunity
    opperation(al|s)? -> operation
    optionnal(ly)? -> optional
    or(gin|ign?i)(al|ally|at(e[ds]?|ing)|s)? -> origin
    overid(e[ns]?|ing) -> override
    overlap(e[ds]?|ing) -> overlapped
    paintshop -> Paint Shop
    paramaters? -> parameter
    (file)?pathes -> paths
    persistan(ce|t(e?ly)?) -> persistence
    prefer(re|a)nces? -> preference
    prefer(e[ds]?|ing) -> preferring
    presense -> presence
    ([iu][mn])?pro(bi|pa)b(l[ye]|ilit(y|ies)) -> probable
    ([iu][mn])?pro(ba|bi|pa)by -> probable
    programatic(ally)? -> programmatic
    (un)?resonn?abl[ey] -> reasonable
    reg(istr|este?r)(ed?|ing) -> registering
    regestr(ars?|ies|y) -> registry
    relativ -> relative
    reles(e[ds]?|ing) -> release
    remeber(ed|ing|s)? -> remember
    reserverd -> reserved
    res(sour?|s?ou)ces? -> resource
    responces? -> response
    (ir)?responsab(ilit(y|ies)|l[ey]) -> responsibility
    resut(ed|ing|s)? -> result
    retre?iv(als?|e[ds]?|ers?|ing) -> retrieve
    retur(e[ds]?|ing) -> returning
    returnes -> returns
    routinues? -> routine
    secound(ly)? -> second
    segements? -> segment
    sences? -> sense
    (off|re|un)?set(tign|ing)s? -> setting
    ship(ed|ing) -> shipping
    soul?dn?t?|shoudn?t? -> should
    splitted -> split
    (infra)?sturct(ure[ds]?)? -> structure
    subscribtions? -> subscription
    substract(e[ds]|ing|ions?|s)? -> subtract
    (un)?successfull -> successful
    succ?e?d(ed|s)? -> succeed
    (un)?suport(able|e[ds]?|ers?|ing(ly)?|ive|ively)? -> support
    supress(e[ds]?|ing|ion)? -> suppress
    (un)?supris(e[ds]?|ing|ingly)? -> surprise
    (a|de|un)?syncron(i[sz]e[drs]?|i[sz]ing|ous(ly)?) -> synchronise
    (sub)?sytems? -> system
    tempor(il)?y -> temporarily
    thats -> that's
    thease -> these
    thier -> their
    throught(out)? -> through
    trafics? -> traffic
    transfer(ed|ing) -> transferred
    transferes -> transfers
    uneeded -> unneeded
    unitiali[sz](ation|e[ds]?|ers?|ing) -> uninitialize
    (un)?useab(ility|le) -> usable
    usefull -> useful
    varios -> various
    ([iu]n)?visab(le|ility) -> visibility
    volenteers? -> volunteer
    whats -> what's
    whereever -> wherever
    wich -> which
    wieght(ed|ing|s)? -> weight
    qith(out)? -> with
    (over|re|under)?writen -> written
    (over|re|under)writt(ers?|ing) -> writing

bad-expression=
#    "([^"]|\\")*\s\\n([^"]|\\")*" -> no space before '\n'
    \ba\s+a\b -> 'a' duplicate
    \bai'?nt\b -> ain't
    \ban\s+an\b -> 'an' duplicate
    \babout\s+about\b -> 'about' duplicate
    \bapplicai -> application
    \b(are|is|was|were)\s+(are|is|was|were)\b -> 'is' duplicate
    \b(are|is|'s|was|way|were)\s+to\s+(bad|big|early|great|high|large|late|little|low|new|recent|small|tall)\b -> too
    \bare'?nt\b -> aren't
    arilly\b -> '...arily' ending
#    atinos?\b -> '...ation' ending
    t(aion|ino)s?\b -> '...tion' ending
    \bbe\s+be\b -> 'be' duplicate
    \b(better|bigger|earlier|greater|higher|larger|later|less(\s+recent)?|lower|more(\s+recent)?|newer|rather|smaller|taller|worse)\s+then\b -> than
    \bby\s+by\b -> 'by' duplicate
    \bcan\s+not\b -> cannot
    \scant\s -> can't
    \bcoud('?nt|n't)?\b -> could
    \bcould'?nt\b -> couldn't
    \bdid'?nt\b -> didn't
    \sdidnt\s -> didn't
    \bdifferent\s*to\b -> different from
    \bdo(es|se)?['n ]t\b -> doesn't
    \sdont\s -> don't
    [cei]aly\b -> '...ally' ending
    erd\b -> '...ered' ending
    \bfor\s+for\b -> 'for' duplicate
    \bhas'?nt\b -> hasn't
    \bhave'?nt\b -> haven't
    \bhavn't\b -> haven't
    \b(s?he)\s+(s?he|it)\b -> 'he' duplicate
    [^l]icly\b|icaly\b -> '...ically' ending
    \bif\s+if\b -> 'if' duplicate
    ifing\b -> '...ifing' ending
    \bin\s+in\b -> 'in' duplicate
    \bisnt\b -> isn't
    \bit\s+it\b -> 'it' duplicate
    \bmean\s+time\b -> meantime
    naly\b -> '...nally' ending
    non\s+exist(ent|ing) -> nonexistent
    nonexistant -> nonexistent
    \bof\s+of\b -> 'of' duplicate
    onnally\b -> '...onaly' ending
    \bprivl -> privilege
    procces -> process
    \bshoud('?nt|n't)?\b -> should
    \bshould'?nt\b -> shouldn't
    \bsome\s+how\b -> somehow
    \bsome\s+what\b -> somewhat
    \bsome\s+where\b -> somewhere
    [^begiouy]eing\b -> '...ing' ending
    [^ecgklmprsvz]eable\b -> '...able' ending
    \bthe\s+the\b -> 'the' duplicate
    then\s+expected -> than
    \btheir\s+(are|is|was|were)\b -> there is
    trys\b -> tries
    ualy\b -> '...ually' ending
    \bunece -> unnecessary
    \bupto\b -> up to
    \bwa(n'|s'?n)t\b -> wasn't
    \bwith\s+with\b -> 'with' duplicate
    \bwould'?nt\b -> wouldn't
bad-case=
    \b[aA]nd\s+and\b -> 'and' duplicate
    [Aa]uthorWare -> Authorware
    Autocad|[Aa]uto(Cad|cAd|caD|CAd|CaD|cAD) -> AutoCAD
    Black?Box|black?Box -> Blackbox
    BlockBuster|blockBuster -> Blockbuster
    Boot(\s*c|C)amp -> Boot Camp
    Codeweavers|codeWeavers -> CodeWeavers
    Crossover|crossOver -> CrossOver
    [Dd]reamWeaver -> Dreamweaver
    directDraw|Directdraw -> DirectDraw
    directInput|Directinput -> DirectInput
    directMusic|Directmusic -> DirectMusic
    directPlay|Directplay -> DirectPlay
    directSound|Directsound -> DirectSound
    directX|Directx -> DirectX
    [Ee]xec[Ss]hield|Exec shield -> Exec Shield
    [Ff]ireWorks -> Fireworks
    Fontforge|fontForge -> FontForge
    Framemaker|frameMaker -> FrameMaker
    Freebsd|[Ff]ree(Bsd|bSd|bsD|BSd|BsD|bSD) -> FreeBSD
    [Ff]reeHand -> FreeHand
    Freetype|freeType -> FreeType
    Frontpage|frontPage -> FrontPage
    Geforce|geForce -> GeForce
    GMail -> Gmail
    Half(L|-?l)ife -> Half-Life or Half life
    [Hh]omeSite -> Homesite
    Installshield|installShield -> InstallShield
    Left4[Dd]ead -> Left 4 Dead
    Linux *world -> LinuxWorld
    \bM(?i:acOSX)\b -> Mac OS X
    \bM(?i:acOS |ac OS)[xX]\b -> Mac OS X
#   Count on the ignore directive to not complain on the correct spelling
    (?i:\bMac OS X\b) -> Mac OS X
    [Mm]acroMedia -> Macromedia
    [Mm]ac *World -> Macworld
    [M]aster[ -]?card|master[ -]?Card -> MasterCard
    [Mm]icroSoft -> Microsoft
    Netmeeting -> NetMeeting
    News?forge -> NewsForge
    Onenote|oneNote -> OneNote
    Pagemaker|pageMaker -> PageMaker
    Paypal|payPal -> PayPal
    [Pp]hotoShop -> Photoshop
    Powerpoint|powerPoint -> PowerPoint
    Pulseaudio|pulseAudio -> PulseAudio
    Quickbooks?|quickBooks? -> QuickBooks
    Quicktime|quickTime -> QuickTime
    Red[Hh]at -> Red Hat
    [Ss]hockWave -> Shockwave
    (Sel|SEl|SeL|seL|sEL|sEl)inux -> SELinux
    Starcraft -> StarCraft
    Su(se|Se|sE) -> SUSE
    Tarent(ell?a|all?a)|Tarant(ela|all?a) -> Tarantella
    Transgaming|transGaming -> TransGaming
    Turbotax|turboTax -> TurboTax
    [Vv][Mm]Ware -> VMware
    Winehq|[Ww]ine(Hq|hQ) -> WineHQ
    Winetools|wineTools -> WineTools
    Wordperfect|wordPerfect -> WordPerfect
    Xrender -> XRender
ignore=
    (?i:anteing)
    BE\s+BE
    \bMACOSX\b
    \bMac OS X\b

include=
    \.(?i:c|cpp|cxx|h|idl|m)$
    \.(l|y)$
    \.(?i:nib|plist|strings)$
    \.(?i:s?html?)$
    \.in$
    \.(?i:pas)$
    \.pm$
    \.php$
    \.py$
    \.(?i:sgml|xml)$
    \.(itcl|itk|tcl)$
    \.(?i:rc)$
    \.spec$
exclude=
    \.(a|o|la|ko|so(\.[0-9]+)*)$
    \.(?i:dll|exe|obj|res|tlb)$
    \.(?i:ncb|opt)$
    \.mo$
    \.(?i:avi|mpeg|mpg)$
    \.(?i:cur|bmp|eps|gif|icns|ico|jpe?g|pdf|png|ps|tiff|xcf|xpm)$
    \.(?i:fon|fnt|ttf)$
    \.(?i:ppt|xls)$
    \.(bz2|deb|gz|rpm|tar|tgz)$
    \.(?i:zip)$
    /CVS/
    /\.cvsignore$
    /\.git/
    /\.gitignore$
    /\.typosrc$
    ~$
    /\.#[^/]*$
    /#[^/]*#$
