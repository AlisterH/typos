#!/usr/bin/perl -w
use strict;
use FileHandle;
use File::Basename;
use Cwd;

my $name0=$0;
$name0 =~ s%^.*/%%;


my $RE_BUNCH=30;

my $verbose;
sub verbose(@)
{
    return print STDERR @_ if ($verbose);
}

my $debug;
sub debug(@)
{
    return print STDERR @_ if ($debug);
}

sub err(@)
{
    print STDERR "$name0:error: ";
    print @_;
}

sub warning(@)
{
    print STDERR "$name0:warning: ";
    print @_;
}


#####
#
# Building file scanners
#
#####

sub scan_check($$$$$$)
{
    my ($allsets, $category, $filename, $lineno, $line, $regexps)=@_;
    my $current=$allsets->{current};
    my $ignore_re=$current->{_ignore_re};

    foreach my $item (@$regexps)
    {
        my $regexp=sprintf($current->{"${category}_format"}, $item);
        next if ($line !~ /$regexp/);
        next if (defined $ignore_re and $line =~ /$ignore_re/);
        if ($current->{by_error})
        {
            my $group=$current->{$category}->{$item};
            push @{$allsets->{errors}->{$group}}, "$filename:$lineno: $line";
        }
        else
        {
            print "$filename:$lineno: $line";
            return 1;
        }
    }
    return 0;
}

sub scan_check_extra($$$$$$)
{
    my ($allsets, $category, $filename, $lineno, $line, $regexps)=@_;
    my $current=$allsets->{current};
    my $ignore_re=$current->{_ignore_re};

    foreach my $item (@$regexps)
    {
        my $regexp=sprintf($current->{"${category}_format"}, $item);
        my $match;
        if ($line =~ /(?:\b|[0-9_])(?:$regexp)(?:\b|[0-9_])/)
        {
            $match=1;
        }
        elsif ($line =~ /[a-z](?:$regexp)(?:\b|[0-9_])\b/)
        {
            my $matched=$&;
            $match=1 if ($matched =~ /^[a-z][A-Z][a-z]*$/);
        }
        elsif ($line =~ /[a-z](?:$regexp)[A-Z]/)
        {
            my $matched=$&;
            $match=1 if ($matched =~ /^[a-z][A-Z][a-z]*[A-Z]$/);
        }
        elsif ($line =~ /(?:\b|[0-9_])(?:$regexp)[A-Z]/)
        {
            my $matched=$&;
            $match=1 if ($matched =~ /^[A-Z][a-z]*[A-Z]$/);
        }
        next if (!$match);
        next if (defined $ignore_re and $line =~ /$ignore_re/);
        if ($current->{by_error})
        {
            my $group=$current->{$category}->{$item};
            push @{$allsets->{errors}->{$group}}, "$filename:$lineno: $line";
        }
        else
        {
            print "$filename:$lineno: $line";
            return 1;
        }
    }
    return 0;
}

sub build_scan_check($$$)
{
    my ($allsets, $current, $category)=@_;

    my @code;
    my @list=sort keys %{$current->{$category}};
    my $checker;
    if ($category eq "_bad-word" and $current->{extra})
    {
        $checker="scan_check_extra";
    }
    else
    {
        $checker="scan_check";
    }
    my $i=0;
    while ($i < @list)
    {
        my @buf;
        for (my $j=$i; $j < $i+$RE_BUNCH and $j < @list; $j++)
        {
            push @buf, $list[$j];
        }
        $i+=$RE_BUNCH;
        my $regexp="(?:" . join("|", @buf) . ")";
        $regexp=sprintf($current->{"${category}_format"}, $regexp);
        push @code, ("if (\$line =~ /$regexp/)",
                     "{",
                     "    my \$regexps=[",
                     (map { "        " . quote_string($_) . "," } @buf),
                     "    ];",
                     "    if ($checker(\$allsets, " . quote_string($category) . ", \$filename, \$lineno, \$line, \$regexps))",
                     "    {",
                     "        next;",
                     "    }",
                     "}");
    }
    return @code;
}

sub build_scanner($$)
{
    my ($allsets, $current)=@_;

    $current->{"_bad-word_format"}=$current->{extra} ? "(?i)\%s" : "(?i)(?:\\b|[0-9_])\%s(?:\\b|[0-9_])";
    $current->{"_bad-expression_format"}="(?i)\%s";
    $current->{"_bad-case_format"}="\\b\%s\\b";
    my @code=("sub ",
              "{",
              "    my (\$fh, \$filename)=\@_;",
              "",
              "    my \$lineno=0;",
              "    while (my \$line=<\$fh>)",
              "    {",
              "        \$lineno++;",
              build_scan_check($allsets, $current, "_bad-word"),
              build_scan_check($allsets, $current, "_bad-expression"),
              build_scan_check($allsets, $current, "_bad-case"),
              "    }",
              "}",
              "");
    if ($debug)
    {
        my $fh=FileHandle->new(">#code.txt#");
        if ($fh)
        {
            print $fh join("\n", @code);
            close ($fh);
        }
    }
    $current->{scanner}=eval join("\n", @code);
    if ($@)
    {
        err("scanner compilation error: $@\n");
        exit 1;
    }
}


#####
#
# Command-line and rc file processing
#
#####

sub rchandle2argv($$)
{
    my ($fh, $filename)=@_;
    verbose("reading '$filename'\n");

    my $argv=[];
    my $lines=[];
    my $repeat;
    my $lineno=0;
    while (my $line=<$fh>)
    {
        $lineno++;
        next if ($line =~ /^\s*#/);
        chomp $line;
        if (defined $repeat)
        {
            if ($line =~ s/^\s+//)
            {
                push @$argv, $repeat, $line;
                push @$lines, $lineno, $lineno;
                next;
            }
            $repeat=undef;
        }
        if ($line =~ s/^([-a-z0-9_]+)\s*=\s*//)
        {
            if ($line eq "")
            {
                $repeat="--$1";
            }
            else
            {
                push @$argv, "--$1", $line;
                push @$lines, $lineno, $lineno;
            }
        }
        elsif ($line =~ /^[a-z0-9_]+$/)
        {
            push @$argv, "--$line";
            push @$lines, $lineno;
        }
        else
        {
            err("$filename:$lineno: invalid line format: $line\n");
            return undef;
        }
    }
    close($fh);
    debug("  -> @$argv\n");
    return ($argv, $lines);
}

sub rcfile2argv($)
{
    my ($filename)=@_;

    my $fh=FileHandle->new($filename);
    if (!$fh)
    {
        err("unable to open '$filename' for reading: $!\n");
        return undef;
    }
    my ($argv, $lines)=rchandle2argv($fh, $filename);
    close($fh);
    return ($argv, $lines);
}

sub get_options_set($$$;$)
{
    my ($argv, $lines, $filename, $extra_options)=@_;
    @ARGV=@$argv if (defined $argv);

    use Getopt::Long;
    Getopt::Long::Configure("pass_through");
    my ($opt_set, @extra);
    if ($extra_options)
    {
        $opt_set=$extra_options;
        @extra=keys %$extra_options;
    }
    else
    {
        $opt_set={};
        @extra=();
    }
    GetOptions($opt_set, @extra,
               "builtin!",
               "rc!",

               "extra!",
               "bad-word=s@",
               "bad-expression=s@",
               "bad-case=s@",
               "ignore=s@",
               "by-error!",

               "get-wikipedia",
               "wikipedia",
               "wiki-file=s",

               "all!",
               "include=s@",
               "exclude=s@");
    if (@ARGV)
    {
        my $i=0;
        foreach my $item (@ARGV)
        {
            if (defined $filename)
            {
                while ($item ne @$argv[$i])
                {
                    $i++;
                }
                err("$filename:@$lines[$i]: unknown option '$item'\n");
            }
            else
            {
                err("unknown option '$item'\n");
            }
        }
        return undef;
    }

    $opt_set->{builtin}=1 if (!defined $opt_set->{builtin});
    $opt_set->{rc}=1 if (!defined $opt_set->{rc});
    $opt_set->{_filename}=$filename;

    # Convert the paths relative to this directory
    my $cur_dir=($filename =~ m!/! ? dirname($filename) : cwd());
    $cur_dir =~ s![][}{)(?.*+\\]!\\$1!g;
    foreach my $key ("include", "exclude")
    {
        if (defined $opt_set->{$key})
        {
            map { s!^\^\./!^$cur_dir/! } @{$opt_set->{$key}};
        }
    }

    return $opt_set;
}

sub read_rc_file($$)
{
    my ($allsets, $filename)=@_;

    my $fh=FileHandle->new($filename);
    if (!$fh)
    {
        err("unable to open '$filename' for reading: $!\n");
        exit 1;
    }
    my ($argv, $lines)=rchandle2argv($fh, $filename);
    close($fh);

    my $opt_set=get_options_set($argv, $lines, $filename);
    push @{$allsets->{rcstack}}, $opt_set;
}

sub merge_regexp_list($$$)
{
    my ($hashed, $key, $list)=@_;

    foreach my $regexp (@$list)
    {
        #debug("$regexp\n");
        my $group=($regexp =~ s/\s+->\s+(.*)$// ? $1 : $regexp);
        $regexp =~ s/\((?!\?)/(?:/g;
        next if ($regexp eq "");
        if (!exists $hashed->{$key}->{$regexp})
        {
            $hashed->{$key}->{$regexp}=$group;
        }
        elsif ($hashed->{$key}->{$regexp} eq $group)
        {
            verbose("duplicate regular expression '$regexp': '$hashed->{$key}->{$regexp}' and '$group'\n");
        }
        else
        {
            verbose("different groups found for regular expression '$regexp': '$hashed->{$key}->{$regexp}' and '$group'\n");
        }
    }
}

sub merge_option_set($$$)
{
    # FIXME: Do we need $allsets here???
    my ($allsets, $merged, $opt_set)=@_;
    verbose("merging '$opt_set->{_filename}'\n"); # FIXME: debug

    foreach my $key (keys %{$opt_set})
    {
        if (!ref $opt_set->{$key})
        {
            if (!exists $merged->{$key})
            {
                $merged->{$key}=$opt_set->{$key};
            }
            elsif ($key !~ /^(_|rc$|builtin$)/)
            {
                verbose("found duplicate '$key' option in '$opt_set->{_filename}'\n");
            }
        }
        elsif ($key =~ /^(bad-word|bad-expression|bad-case|ignore|include|exclude)$/)
        {
            merge_regexp_list($merged, "_$key", $opt_set->{$key});
        }
    }
}

sub get_current_options($$)
{
    my ($allsets, $dir)=@_;
    my $new;

    my $filename="$dir/.typosrc";
    if ($allsets->{cmdline}->{rc} and -f $filename)
    {
        read_rc_file($allsets, $filename);
    }
    else
    {
        $new=$allsets->{merged_stack}->[-1];
    }
    if (!$new)
    {
        $new={};
        # Merge all the option sets into one
        merge_option_set($allsets, $new, $allsets->{cmdline});
        if ($allsets->{cmdline}->{rc} and defined $allsets->{rcstack})
        {
            my $i=@{$allsets->{rcstack}};
            while ($i > 0)
            {
                $i--;
                merge_option_set($allsets, $new, $allsets->{rcstack}->[$i]);
                print "new_exclude=[",join(" | ",keys %{$new->{_exclude}}), "]\n";
                last if (!$new->{rc});
            }
        }
        if ($new->{builtin})
        {
            merge_option_set($allsets, $new, $allsets->{builtin});
        }
        if ($new->{all})
        {
            delete $new->{_include};
        }
        else
        {
            $new->{_include_re}=list_to_regexp($new->{_include});
        }
        $new->{_exclude_re}=list_to_regexp($new->{_exclude});
        $new->{_ignore_re}=list_to_regexp($new->{_ignore});
        # FIXME: Try not to rebuild the scanner if not strictly necessary
        build_scanner($allsets, $new);
    }
    push @{$allsets->{merged_stack}}, $new;
    $allsets->{current}=$new;
    return $new;
}

sub pop_current_options($)
{
    my ($allsets)=@_;

    pop @{$allsets->{merged_stack}};
    $allsets->{current}=$allsets->{merged_stack}>[-1];
}


#####
#
# Read the bad words
#
#####

sub split_spec_line($)
{
    my ($spec)=@_;
    return ($1, $2) if ($spec =~ /^(.*)\s*-(?:>|&gt;)\s*(.*)$/);
    return ($spec);
}

sub list_to_regexp($)
{
    my ($list)=@_;
    return undef if (!defined $list or !%$list);
    return "(?:" . join("|", keys %$list) . ")";
}

sub quote_string($)
{
    my ($str)=@_;
    $str =~ s!\\!\\\\!g;
    $str =~ s!([\"\$\@\%])!\\$1!g;
    return "\"$str\"";
}

sub scan_file($$$)
{
    my ($allsets, $current, $filename)=@_;

    my $fh=FileHandle->new("$allsets->{rootdir}/$filename");
    if (!$fh)
    {
        err("unable to open '$filename' for reading: $!\n");
        return 0;
    }
    debug("scanning '$filename'\n");
    $current->{scanner}($fh, $filename);
    close($fh);
}

sub scan_directory($$);
sub scan_directory($$)
{
    my ($allsets, $dir)=@_;
    verbose("Entering the ", ($dir ? "'$dir'" : "root"), " directory\n");

    my $current=get_current_options($allsets, "$allsets->{rootdir}/$dir");
    debug("current options=[",join(" ", keys %$current),"]\n");
    my $include_re=$current->{_include_re};
    my $exclude_re=$current->{_exclude_re};
    debug("exclude_re=[$exclude_re]\n");

    my @subdirs;
    local *DIR;
    if (!opendir DIR, "$allsets->{rootdir}/$dir")
    {
        err("unable to open the '$allsets->{rootdir}/$dir' directory\n");
        return;
    }
    foreach my $dentry (readdir(DIR))
    {
        next if ($dentry eq "." or $dentry eq "..");
        $dentry="$dir$dentry";
        my $fullpath="$allsets->{rootdir}/$dentry";
        if (-d $fullpath)
        {
            if (-l $fullpath)
            {
                debug("$dentry/: skipping directory symbolic link\n");
                next;
            }
            $fullpath.="/";
            if ($exclude_re and $fullpath =~ /$exclude_re/)
            {
                verbose("$dentry/: skipping blacklisted directory\n");
                next;
            }
            push @subdirs, $dentry;
            next;
        }
        if (defined $include_re and $fullpath !~ /$include_re/)
        {
            verbose("$dentry: not in scanning whitelist\n");
            next;
        }
        if ($exclude_re and $fullpath =~ /$exclude_re/)
        {
            verbose("$dentry: skipping blacklisted file\n");
            next;
        }
        scan_file($allsets, $current, $dentry);
    }
    closedir(DIR);

    foreach my $subdir (@subdirs)
    {
        scan_directory($allsets, "$subdir/");
    }
    pop_current_options($allsets);
}

sub print_errors($)
{
    my ($allsets)=@_;
    while (my ($group, $list)=each %{$allsets->{errors}})
    {
        print "\n$group:\n";
        print @$list;
    }
}


#####
#
# Main
#
#####

my ($opt_help);
my $global_options={"debug"   => \$debug,
                    "verbose" => \$verbose,
                    "help"    => \$opt_help
                   };
my $allsets={ rootdir => cwd() };
$allsets->{cmdline}=get_options_set(undef, undef, "cmdline", $global_options);
if (!defined $allsets->{cmdline})
{
    err("try running $name0 --help\n");
    exit 2;
}
$verbose=1 if ($debug);
if ($opt_help)
{
    print "Usage: $name0 [--no-builtin] [--debug] [--verbose] [--help]\n";
    print "             [--bad-word WORD] [--bad-expression EXPR] [--bad-case CASE]\n";
    print "             [--get-wikipedia] [--wikipedia] [--wiki-file FILE]\n";
    print "             [--include SCAN] [--exclude SKIP]\n";

    print "\n";
    print "Scans files for common misspellings and case errors.\n";

    print "\n";
    print "Options:\n";
    print "  --no-builtin   Don't use the builtin list of typos and files scanning options\n";
    print "  --bad-word WORD   FIXME\n";
    print "  --bad-expression EXPR  FIXME\n";
    print "  --bad-case CASE   FIXME\n";
    print "  --ignore IGN   FIXME\n";
    print "  --get-wikipedia   Download Wikipedia's list of common misspelling's\n";
    print "  --wikipedia       Use Wikipedia's list of common misspellings\n";
    print "  --wiki-file FILE  Specifies an alternate file containing the Wikipedia common misspellings\n";
    print "  --all             Scan all files not matched by an exclude file pattern\n";
    print "                      By default, only files matching an include file pattern\n";
    print "                      and not matching an exclude file pattern are scanned\n";
    print "  --include SCAN    File pattern identifying files to scan\n";
    print "  --exclude SKIP    File pattern identifying files not to scan, typically\n";
    print "                      because they are binary files or backup files\n";

    print "\n";
    print "File patterns:\n";
    print "  Patterns starting with '^./' identify files relative to the corresponding\n";
    print "  .typosrc directory, or to the current directory for command line options.\n";
    print "   All other file patterns are matched against the file's full path name.\n";
    exit 0;
}

if ($allsets->{cmdline}->{rc})
{
    my $path=cwd();
    my @stack;
    while (1)
    {
        $path=dirname($path);
        last if (!-o $path);
        unshift @stack, basename($path);
    }
    foreach my $dir (@stack)
    {
        $path="$path/$dir";
        read_rc_file($allsets, "$path/.typosrc") if (-f "$path/.typosrc");
    }
}

if ($allsets->{cmdline}->{builtin})
{
    # Read builtin files
    my ($argv, $lines)=rchandle2argv(*DATA, "builtin");
    $allsets->{builtin}=get_options_set($argv, $lines, "builtin");
}

# FIXME: Wrong place for this, should be done somewhere in get_current_options()
#if ($opt_wikipedia)
#{
#    $opt_wiki_file=dirname($0) . ".wikipedia" if (!defined $opt_wiki_file);
#}

scan_directory($allsets, "");
print_errors($allsets);

exit 0;

__DATA__
bad-word=
    abscen(ce|t)
    accellerat(e[ds]?|in|or)
    acc?eptible -> acceptable
    ([iu]n)?acc?ess?ab(le|ility) -> accessibility
    acc?omodat(es?|ing) -> accommodate
    addres(ed|es|ing)?|adress?(ed|es|ing)? -> address
    allowes -> allows
    allready -> already
    allways -> always
    alot -> a lot
    altrought? -> although
    anali[sz]e[sd]? -> analyzed
    appartments? -> apartment
    arithmatic -> arithmetic
    att?achements? -> attachment
    atleast -> at least
    automaticly -> automatically
    awhile -> a while
    begining -> beginning
    beeing -> being
    belive -> believe
    boundr(y|ies) -> boundary
    capatibl(e|ities|ity) -> capable
    careful[ly] -> carefully
    cateogor(y|ies) -> categories
    codeweaver -> CodeWeavers
    comands? -> command
    comparasons?
    ([iu]n)?compatab(le|ility|ilities) -> compatibility
    completly -> completely
    concensus -> consensus
    ([iu]n)?consistan(ci?es|cy|t|tly) -> consistency
    (dis)?contigous(ly)?|(dis)?continous(ly)? -> continuously
    convertions? -> conversions
    crete -> create
    debug(ing|ed|er) -> debugging
    (de|in)cres(ed?|es?|ing(ly)?) -> decrease
    definate?ly|definitly -> definitely
    dependan(cy|cies|t)|depand[ae]n(cy|cies|t) -> dependency
    developements? -> devlopment
    dissabl(e[ds]?|ing) -> disable
    dissapp?ear(ances?|ed|ing|s)?|disapear(ances?|ed|ing|s)? -> disappear
    dynamicly -> dynamically
    easly -> easily
    editt(ed|ing|or) -> editing
    effecien(ce|cy|t) -> efficiency
    eigther -> either
    enought -> enough
    eventhought? -> eventhough
    enviro(ne)?ments? -> environment
    executeable -> executable
    existan(t|ce) -> existent
    extentions? -> extension
    ([iu]n)?feasab(le|ility) -> feasible
    feild?(ed|s|ing)? -> failed
    (un)?fortunatly -> fortunately
    funtion(ality|ally|ed|ing|s)? -> functionning
    grammer -> grammar
    happends? -> happens
    (un)?helpfull -> helpful
    hexidecimal -> hexadecimal
    higly -> highly
    (ex|im)plicite -> implicit
    (un)?impl(eman|i?men|emena)t(ations?|ed|ers?|ing|s)? -> implementation
    incase -> in case
    incomming -> incoming
    (un)?initili[sz](es?|ing) -> initialize
    (un)?instal(able|ation|e[dr]|ing) -> installable
    (un)?intergrat(e[ds]?|ing|ion) -> integrated
    (un?)interprett(ed|ing) -> interpreted
    (un)?int(er|re)st(ed|ing|s)? -> interest
    invokat(e|ion) -> invocation
    (i?un)?kown -> known
    lenght(en|s)? ->length
    mesages? -> message
    occassion(ally|s)? -> occasionally
    occur(ed|ences?|es|ing) -> occurrence
    (un)?offical(ly|s)? -> official
    ommit(ed|ing|ted|s)? -> omit
    oportunit(y|ies) -> opportunity
    opperation(al|s)? -> operation
    optionnal(ly)?|overid(e|en|es|ing) -> optional
    orgin(al|at(e[ds]?|ing)|s)? -> origin
    overid(e[ns]?|ing) -> override
    paintshop -> Paint Shop FIXME
    paramaters? -> parameter
    (file)?pathes -> paths
    persistan(t|ce) -> persistence
    preceed(ed|ing|s)? -> preceding
    prefer(ed|ing) -> preferring
    presense -> presence
    privi?l(a|ed)ges? -> privilege
    probibl[ye] -> probable
    propogat(e[ds]?|ion) -> propagate
    publicall?y -> publicly
    registr(ed?|ing) -> registering
    responces? -> responce
    responsab(ilit(y|ies)|l[ey]) -> responsibility
    retre?iv(als?|ed?|es|ing) -> retrieve
    returing -> returning
    returnes -> returns
    secound(ly)? -> second
    sences? -> sense
    seperat(e[ds]?|ing|ions?|ors?) -> separate
    shedul(ers?|ing) -> scheduler
    simmilar(ity|ly)? -> similar
    (infra)?sturct(ure[ds]?)? -> structure
    subscribtions? -> subscription
    (un)?successfull|(un)?succesful(ly)?|(un)?sucess?ful(ly?)? -> successful
    supercee?d(ed|ing|s)?|superseed(eding|s)?|superseds -> supersedes
    (un)?suport(able|ed|er|ing|ive|ively)? -> supported
    supress(e[ds]|ion)? -> suppress
    a?syncronous(ly)? -> synchronously
    tempor(il)?y -> temporarily
    thease -> these
    thier -> their
    threshholds? -> threshold
    trafics? -> traffic
    transfer(ed|ing) -> transferred
    transferes -> transfers
    truely -> truly
    uneeded -> unneeded
    usefull -> useful
    varios -> various
    ([iu]n)?visab(le|ility) -> visibility
    wether -> whether
    whereever -> wherever
    wieght(ed|ing|s)? -> weight
    wierd(er|ly)? -> weird
    (over|re)?writen -> written
    writting -> writing
bad-expression=
    \ban?\s+an?\b -> duplicate
    \babout\s+about\b -> duplicate
    \band\s+and\b -> duplicate
    \bapplicai -> application
    \b(are|is|was|were)\s+(are|is|was|were)\b -> duplicate
    \b(are|is|was|were)\s+to\s+(big|large|little|small)\b -> too
    \barent\b -> aren't
    \bbe\s+be\b -> duplicate
    (better|less|more|rather|worse)\s+then -> than
    \by\s+by\b -> duplicate
    \bcant\b -> can't
    \bcan\s+not\b -> cannot
    \bcouldnt\b -> couldn't
    \bdidnt\b -> didn't
    \bdifferent\s*to\b -> different from
    \bdo(es)?nt\b -> doesn't
    \bdosen.t\b -> doesn't
    \bfor\s+for\b -> duplicate
    \bhasnt\b -> hasn't
    \bhavent\b -> haven't
    \b(s?he|it)\s+(s?he|it)\b -> duplicate
    \bheirar?ch|\bhierach -> hierarchy
    [^l]icly\b|icaly\b -> '...ically' ending
    \bif\s+if\b -> duplicate
    ifing\b -> duplicate
    \bin\s+in\b -> duplicate
    \bisnt\b -> isn't
    \bmean\s+time\b -> meantime
    necces|necesar|\b(un)?nesses|nessary\b -> necessary
    naly\b -> '...nally' ending
    non(\s+|-)exist(ent|ing) -> nonexistent
    \bof\s+of\b -> duplicate
    onnally\b -> '...onaly' ending
    \bprivl -> privilege
    procces -> process
    reciev -> receive
    \bshouldnt\b -> shouldn't
    \bsome\s+how\b -> somehow
    \bsome\s+what\b -> somewhat
    \bsome\s+where\b -> somewhere
    then\s+expected -> than
    \btheir\s+(are|is|was|were)\b -> there is
    trys\b -> tries
    \bunece -> unnecessary
    \bupto\b -> up to
    \bwasnt\b -> wasn't
    \bwith\s+with\b -> duplicate
    \bwont\b -> won't
    \bwouldnt\b -> wouldn't
bad-case=
    AuthorWare -> Authorware
    Auto(cad|Cad|cAd|caD|CAd|CaD|cAD) -> AutoCAD
    Codeweavers -> CodeWeavers
    Crossover -> CrossOver
    [Dd]reamWeaver -> Dreamweaver
    [Ff]ireWorks -> Fireworks
    Fontforge|fontForge -> FontForge
    Framemaker -> FrameMaker
    Free(bsd|Bsd|bSd|bsD|BSd|BsD|bSD) -> FreeBSD
    [Ff]reeHand -> FreeHand
    Freetype|freeType -> FreeType
    [Hh]omeSite -> Homesite
    Installshield -> InstallShield
    [Mm]acroMedia -> Macromedia
    [Mm]icroSoft -> Microsoft
    News?forge -> NewsForge
    Pagemaker -> PageMaker
    [Pp]hotoShop -> Photoshop
    Powerpoint -> PowerPoint
    Quickbooks -> QuickBooks
    Quicktime -> QuickTime
    Redhat -> Red Hat
    [Ss]hockWave -> Shockwave
    Su(se|Se|sE) -> SUSE
    Tarent(ell?a|all?a)|Tarant(ela|all?a) -> Tarantella
    Transgaming -> TransGaming
    Turbotax -> TurboTax
    Wine(hq|Hq|hQ) -> WineHQ
    Winetools|wineTools -> WineTools
    Wordperfect -> WordPerfect
include=
    \.(?i:c|cpp|cxx|h|idl|m)$
    \.(l|y)$
    \.(?i:nib|plist|strings)$
    \.(?i:s?html?)$
    \.in$
    \.(?i:pas)$
    \.pm$
    \.php$
    \.(?i:sgml|xml)$
    \.(itcl|itk|tcl)$
    \.(?i:rc)$
    \.spec$
exclude=
    \.(a|o|la|ko|so)$
    \.(?i:dll|exe|obj|res|tlb)$
    \.(?i:ncb|opt)$
    \.mo$
    \.(?i:avi|mpeg|mpg)$
    \.(?i:cur|bmp|eps|gif|icns|ico|jpe?g|pdf|png|ps|tiff|xcf|xpm)$
    \.(?i:fon|fnt|ttf)$
    \.(?i:ppt|xls)$
    \.(bz2|deb|gz|rpm|tar|tgz)$
    \.(?i:zip)$
    /CVS/
    /\.cvsignore$
    /\.git/
    /\.gitignore$
    /\.typosrc$
    ~$
    /\.#[^/]*$
    /#[^/]*#$
